== Developer Guide

=== Prerequisites
To build the Mobi source code, you must have the following software and tools installed.

[cols="3*",options="header"]
|===
|Technology
|Version
|Download Link

|Java
|17
|http://www.oracle.com/technetwork/java/javase/downloads/index.html

|Maven
|3.6+
|https://maven.apache.org/download.cgi

|Node.js
|14+
|https://nodejs.org/en/download/

|Google Chrome
|105+
|https://www.google.com/chrome/

|===

=== Build from Source
Clone the Mobi project from https://github.com/matonto/matonto[GitHub] and navigate to that directory on your machine. Run the following command to build the source:

[source,bash]
----
mvn clean install
----

The build creates the Mobi distribution as both a `.tar.gz` file and a `.zip` file in the `mobi-distribution/target` directory. Extract one of the files and navigate into that directory.

Inside the extracted distribution directory, start up the Mobi Karaf instance. For Unix/Linux:

[source,bash]
----
bin/start
----

or for Windows:

[source,powershell]
----
bin\start.bat
----

All the Mobi bundles and services and their dependencies will be automatically deployed using OBR.

The Mobi web application should now be accessible at `https://localhost:8443/mobi/index.html`.

==== OntologyCache Configuration File
Mobi utilizes the Repository Cache Ontology API implementation to represent Ontologies.

Configuration file for the CacheRepositoryCleanup job:
[source,bash]
----
com.mobi.cache.impl.repository.CleanupRepositoryCache.cfg
----

This file is responsible for deleting stale ontologies within the repository after a specified period in order to preserve resources and improve processing. The format looks like the following:
[source,plaintext]
----
repoId = ontologyCache
expiry = 1800
scheduler.expression=0 0 * * * ?
----

==== Clearing Pre-existing Configurations in Karaf
If Mobi has been run with the OWLAPI implementation prior to using the Repository Cache implementation, a configuration object will have been stored in Karaf and must be removed.

From the Karaf terminal run:
[source,plaintext]
----
karaf@mobi()> config:delete com.mobi.ontology.impl.owlapi.OntologyManager
----

In order to revert back to the OWLAPI implementation after the Repository cache implementation has been launched, run the following:
[source,plaintext]
----
karaf@mobi()> config:delete com.mobi.ontology.impl.repository.OntologyManager
----

=== Load Dataset Data
Data can be manually loaded into an existing <<datasets-manager-guide,Dataset>> using the Mobi shell. You will need the full path to the data file and the IRI of the target DatasetRecord.

Open the <<mobi-shell-guide,Mobi shell>> and run the `mobi:import` command passing the IRI of the DatasetRecord and the path to the data file. For example, if you wanted to load data located at `/Users/tester/Documents/testData.trig` into the `\https://mobi.com/records/my-dataset` DatasetRecord, you would run the following command:

[source,plaintext]
----
mobi:import --dataset https://mobi.com/records/my-dataset /Users/tester/Documents/testData.trig
----

All triples that are not within a named graph will be loaded into the <<systemDefaultNamedGraph,system default named graph>>. All triples within named graphs will be added and their named graphs associated with the Dataset.

=== Accessing Swagger REST API Documentation
Every installation of Mobi provides https://swagger.io/[Swagger] Documentation for the full suite of Mobi REST APIs. This documentation is provided as a standard Swagger YAML file as well as a fully interactive hosted version. The Swagger YAML file can be downloaded at `$MOBI_HOST/swagger-ui/mobi-swagger.yaml`. To reach the Swagger Documentation UI, navigate to `$MOBI_HOST/swagger-ui/index.html`. For example, in a default deployment these URLs would look like https://localhost:8443/swagger-ui/mobi-swagger.yaml and https://localhost:8443/swagger-ui/index.html, respectively.

image::developer-guide/swagger-docs.png[Swagger REST API Documentation,align="center"]

=== Translating Documents
Files in the xml, json, or csv formats can be transformed into an ontology and corresponding instance data using Mobi's
document translation tool. This experimental feature can be utilized via REST endpoint, the <<mobi-shell-guide,Mobi shell>>,
or from the <<Accessing Swagger REST API Documentation,Swagger UI>>, with all methods providing users configuration
options to alter the generated files.

==== Utilizing the Mobi Shell
The tool can be run from the Mobi shell with the `mobi:document-translate` command. The command accepts the full path
to both the input file to translate and output location for the result. Below is an example call to the command:
[source,plaintext]
----
mobi:document-translate /Users/tester/Documents/example.json /Users/tester/Documents/outputDir
----
The Document Translate command accepts several additional configuration options to tailor the way the input file is
processed. These options currently include the ability to set the default namespace of the generated ontology and
instance data, specify the type of file being translated, and set a number of rows in a CSV to be analyzed before
identifying a data property range. The command result is a zip file located at the output destination that contains two
turtle files: ontology.ttl which will contain an ontology describing the structure of the input file and data.ttl which
will contain the data within your input file translated into RDF data conforming to the ontology.

==== Utilizing the REST endpoints and Swagger UI
Mobi's REST endpoints & Swagger UI provide additional ways to use the document translation tool. When using either a
direct REST call or the Swagger UI, users are able to select an input file from their filesystem and convert it to valid RDF.
If successful, output is returned as a downloadable zip file. Similar to the output generated by the Mobi shell, this
zip file contains two turtle files containing the generated ontology and conforming instance data respectively.
Additionally, these two methods provides users the same configurable options that the Mobi shell does, with one
additional option. When using Rest endpoints or the Swagger UI to translate a document, users are able to also
specify the name of the output file. If one is not specified, the name of the input file will be used with a timestamp
added on to the end.

image::developer-guide/translate-swagger-ui.png[Document Translation Swagger Documentaion,align="center"]
image::developer-guide/translate-postman-ui.png[Document Translation Postman Documentaion,align="center"]

==== Translating Different File Types

===== XML
The XML translator uses the hierarchical structure of the XML input file in order to construct classes and object
properties.

.XML Example File
image::developer-guide/XML_input_file.png[XML Input File,align="left"]

When generating the ontology, each element is simultaneously treated as a class and object property if it
has child elements and is regarded as a datatype property if it does not. The output will resemble a file similar
to the one below.

.XML Example Ontology File
image::developer-guide/XML_ont_file.png[XML Ontology Ouput File,align="left"]

The generated data file is composed of elements that have been deemed a class and that have literal values attached to it.
Each instance is given a unique IRI based on the namespace of the ontology with a trailing UUID attached at the end.

.XML Example Data File
image::developer-guide/XML_data_file.png[XML Data Output File,align="left"]

===== JSON
Given a JSON file like below, the JSON translator will use the nested structure of JSON objects in order to construct 
classes and object properties.

.JSON Example File
image::developer-guide/JSON_file_input.png[JSON Input File,align="left"]

An output ontology is then generated using the passed in IRI or a UUID as the namespace. Classes and object properties 
relating these classes are created based on the keys present in the input file.

.JSON Example Ontology File
image::developer-guide/JSON_ont_output.png[JSON Ontology Output File,align="left"]

The generated data file is created by utilizing the literal values of each key object. For each instance of a JSON 
object there is in the input file an RDF entity is created with the same namespace as the ontology.

.JSON Example Data File
image::developer-guide/JSON_data_output.png[JSON Data Output File,align="left"]

===== CSV
The CSV translation tool is the only translator that does not create multiple classes or any object properties. A
singular class is generated per file, with the name of the file being used as the name of the class.

.CSV Example File
image::developer-guide/CSV_input_file.png[CSV Input File,align="left"]

Each column header is treated as a different datatype property, with the translator parsing a certain number of rows to
determine the range of the property.

.CSV Example Ontology File
image::developer-guide/CSV_ont_output.png[CSV Ontology Ouput File,align="left"]

When creating the instance data, each row within the file is treated as an instance of the class with
the cell values being the object of the triples generated by the datatype properties.

.CSV Example Data File
image::developer-guide/CSV_data_output.png[CSV Data Output File,align="left"]
